# Шпаргалка по командам Git

+ [Ввведение](https://github.com/LizonkaElizaveta/GitTutorial/tree/master/#Введение)
+ [Основы Git](https://github.com/LizonkaElizaveta/GitTutorial/tree/master/#Основы-Git)
+ [Ветвление в Git](https://github.com/LizonkaElizaveta/GitTutorial/tree/master/#Ветвление-в-Git)
+ Git на сервере
+ Распределенный Git
+ Инструменты Git
+ Настройка Git
+ Git изнутри

## Введение
Git — система управления версиями(СУВ). Главное отличие Git от других СУВ в том, что когда мы фиксируем текущую версию проекта, то Git сохраняет лишь слепок того как выглядят все файлы проекта на текущий момент. Если файл не менялся, то Git не сохраняет файлы снова, а делает ссылку на ранее сохраненный файл.

В Git почти все операции локальные, т.к. вся история проекта хранится локально на компьютере, которую не нужно скачивать с сервера. Когда сохраняется файл, Git вычисляет контрольную сумму и она становится индексом это файла. Механизм, используемый Git для вычисления контрольных сумм, называется SHA-1 хеш.
Это строка из 40 шестнадцатеричных знаков (0-9 и a-f), которая вычисляется на основе содержимого
файла или структуры каталога, хранимого Git.

### Три состояния файлов в Git

+ Зафиксированное состояние (каталог Git) - файлы уже сохранены в вашей локальной базе.
+ Измененное состояние (рабочий каталог) - файлы, которые поменялись, еще не были зафиксированы.
+ Подготовленное состояние (область подготовленных файлов или индекс) - измененные файлы, отмеченные для включение в следующий коммит. 


### Цикл работы
1. Изменяем файл в рабочем каталоге.
2. Подготавливаем файлы, добавляя слепки в индекс (указание для Git какие изменения нужно будет закоммитить).
3. Делаем коммит. Слепки сохраняются в каталог Git.


### Настройки

Первое, что нужно сделать после установки Git - это указать имя пользователя и почту:

```bash
$ git config --global user.name "LizonkaElizaveta"
$ git config --global user.email liza_soft_1313@mail.ru
```
```bash
$ git config --list     # проверить используемые настройки

$ git config {ключ}     # проверить значение конкретного ключа
$ git config user.name

$ git help <команда>    # для получения помощи при использовании Git
$ git help config
 ```
## Основы Git

### Создание репозитория
```bash
$ git init             # создать новый проект в текущей директории
$ git init folder-name # создать новый проект в указанной директории
```  
### Копирование существующего репозитория
``` bash
$ git clone [url]
$ git clone git://github.com/schacon/grit.git            # клонировать удаленный репозиторий в одноименную директорию
$ git clone git://github.com/schacon/grit.git FolderName # клонировать репозиторий в другой каталог
$ git clone https://github.com:nicothin/web-design.git . # клонировать репозиторий в текущую директорию
```
### Определение состояния/изменений файлов
``` bash
$ git status
# On branch master
nothing to commit (working directory clean)
```
Это означает, что рабочий каталог чистый (в нем нет измененных файлов) и вы находитесь на ветке master. Если добавить новый файл в проект, которого не было раньше, то можно увидить неотслеживаемый (отсутствующий в предыдущем коммите) файл: 
``` bash
$ vim README
$ git status
# On branch master
# Untracked files:
# (use "git add <file>..." to include in what will be committed)
#
# README
nothing added to commit but untracked files present (use "git add" to track)
```
Git не станет явно добавлять этот файл, пока вы явно ему это не укажете.
``` bash
$ git diff            # сравнивает содержимое вашего рабочего каталога с содержимым индекса(посмотреть непроиндексированные изменения)
$ git diff --cached   # сравнивает индексированные изменения с последним коммитом
```
### Добавление новых файлов 
``` bash
git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий
git add README   # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)
```
### Игнорирование файлов
``` bash
$ cat .gitignore # создается файл .gitignore, где будут хранится перечисленные шаблоны игнорируемых файлов
*.[oa]           # игнорируем файлы, заканчивающие на .о (объектные) и .а (архивные)
*~               # игнорируем файлы, заканчивающие на тильду (временные файлы)
```


### Фиксация  изменений
``` bash
$ git commit -v                     # разница/diff ваших изменений(вы сможете точно увидеть всё что сделано)
$ git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение
$ git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы), позволяя вам обойтись без git add, закоммитить и добавить сообщение
```

### Удаление файлов
``` bash
$ rm text.txt                # удалить файл из вашего рабочего каталога, после файл попадает в секцию Changed but not updated»
$ git rm text.txt            # удалить отслеживаемый неизменённый файл и проиндексировать это изменение
$ git rm -f text.txt         # удалить отслеживаемый изменённый файл и проиндексировать это изменение
$ git rm --cached readme.txt # удалить файл из индекса, оставив его при этом в вашем рабочем каталоге (часто используется для нечаянно добавленных в отслеживаемые файлов)
$ git rm -r log/             # удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение
$ git rm ind*                # удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение
```
### Перемещение файлов
Git не отслеживает непосредственно перемещение файла. Если вы переименуете файл в git, то в git не сохранится никаких метаданных о том, что вы переименовали файл.
``` bash
$ git mv file_from file_to # переименовать файл в git
```
### Просмотр истории коммитов
``` bash
$ git log                         # список коммитов созданных в данном репозитории в обратном хронологическом порядке
$ git log master                  # показать коммиты в указанной ветке
$ git log -2                      # показать последние 2 коммита в активной ветке
$ git log -2 --stat               # показать последние 2 коммита и статистику внесенных ими изменений
$ git log -p -22                  # показать последние 22 коммита и внесенную ими разницу на уровне строк
$ git log --graph -10             # показать последние 10 коммитов с ASCII-представлением ветвления (историю ветвлений и слияний) 
$ git log --since=2.weeks         # показать коммиты за последние 2 недели
$ git log --after '2018-06-30'    # показать коммиты, сделанные после указанной даты (м.б --until, --author, --committer)
$ git log index.html              # показать историю изменений файла index.html (только коммиты)
$ git log -5 index.html           # показать историю изменений файла index.html, последние 5 коммитов (только коммиты) 
$ git log -p index.html           # показать историю изменений файла index.html (коммиты и изменения)
$ git log -G'myFunction' -p       # показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)
$ git log -L '/<head>/','/<\/head>/':index.html # показать изменения от указанного до указанного регулярных выражений в указанном файле
$ git log --grep fix              # показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)
$ git log --grep fix -i           # показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)
$ git log --grep 'fix(ing|me)' -P # показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)
$ git log --pretty=oneline        # выводит каждый коммит в одну строку(м.б =short, =full,  =fuller)
$ git log --pretty=format:"%h - %an, %ar : %s" -4 # показать последние 4 коммита с форматированием выводимых данных
$ git log master..branch_99       # показать коммиты из ветки branch_99, которые не влиты в master
$ git log branch_99..master       # показать коммиты из ветки master, которые не влиты в branch_99
$ git log master...branch_99 --boundary -- graph # показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)
```
Наиболее полезные параметры форматов для pretty=format:
``` bash
`%H`Хеш коммита
`%h`Сокращенный хеш коммита
`%T`Хеш дерева
`%t`Сокращенный хеш дерева
`%P`Хеши родительских коммитов
`%p`Сокращенные хеши родительских коммитов
`%an`Имя автора
`%ae`Электронная почта автора
`%ad`Дата автора (формат соответствует параметру --date= )
`%ar`Дата автора, относительная (пр. "2 мес. назад")
`%cn`Имя коммитера (челове, последний применивший действия)
`%ce`Электронная почта коммитера
`%cd`Дата коммитера
`%cr`Дата коммитера, относительная
`%s`Комментарий
```

### Отмена изменений
Допустим, вы внесли изменения в два файла и хотите записать их как два отдельных коммита, но случайно набрали *git add * и проиндексировали оба файла. Как теперь отменить индексацию одного из двух файлов?
``` bash
$ git reset HEAD benchmarks.rb # отмена индексации файла
$ git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения
git revert b9533bb --no-edit   # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)
```
Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий:
``` bash
$ git commit --amend "Название" # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)
```

### Восстановление изменений
``` bash
$ git checkout -- benchmarks.rb    # отменить сделанные изменения (все сделанные вами изменения в этом файле пропали — вы просто скопировали поверх него другой файл)
$ git checkout 5589877 index.html  # восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)
```

### Удаленные репозитории
Удалённые репозитории— это модификации проекта, которые хранятся в интернете или ещё где-то в сети. Их может быть несколько,каждый из которых, как правило, доступен для вас либо только на чтение, либо на чтение и запись. 
``` bash
$ git remote -v              # показать список удалённых репозиториев, связанных с локальным
$ git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
$ git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
$ git remote rm origin       # удалить привязку удалённого репозитория
$ git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
$ git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
$ git fetch origin master    # то же, но скачивается только указанная ветка
$ git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
$ git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
$ git pull origin            # влить изменения с удалённого репозитория (все ветки)
$ git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)
```

### Работа с метками(теги)
Как и большинство СУВ, Git имеет возможность помечать (tag) определённые моменты в истории как важные. Как правило, этот функционал используется для отметки моментов выпуска версий (v1.0, и т.п.).
``` bash
$ git tag                                    # перечисление меток в алфавитном порядке
$ git tag -l 'v1.4.2.*'                      # показать все теги выпуска 1.4.2.
$ git tag -a v1.4 -m 'my version 1.4'        # создание аннотированной метки (метки, которые хранятся в БД как полноценные объекты)
$ git tag -a -m 'В продакшен!' v1.0.1 master # создать тег с описанием на том коммите, на который смотрит ветка master
$ git tag -d v1.0.0                          # удалить тег с указанным именем(ами)
$ git tag -n                                 # показать все теги, и по 1 строке сообщения коммитов, на которые они указывают
$ git tag -n -l 'v1.*'                       # показать все теги, которые начинаются с 'v1.*'
$ git show v1.4                              # посмотреть данные метки вместе с коммитом, который был помечен
$ git tag -s v1.5 -m 'my signed 1.5 tag'     # подписать метку с помощью GPG (если есть ключ)
```

### Полезное
``` bash
$ git co<tab><tab> # автоматическое дополнение, вывести комманды на "co"
$ git log --s<tab> # посмотреть какие опции можно применить к операции
$ git config --global alias.ci commit # псевдоним, теперь при наборе команды commit достаточно написать git ci
$ git config --global alias.last 'log -1 HEAD' # теперь  git last - посмотреть последний коммит
```

## Ветвление в Git

### Ветки
``` bash
$ git branch                 # показать список веток
$ git branch -v              # показать список веток и последний коммит в каждой
$ git branch new_branch      # создать новую ветку с указанным именем на текущем коммите
$ git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите
$ git branch -f master 5589877  # переместить ветку master на указанный коммит
$ git branch -f master master~2 # переместить ветку master на 2 коммита назад
$ git checkout new_branch    # перейти в указанную ветку
$ git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё
$ git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё
$ git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
$ git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
$ git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
$ git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния
$ git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
$ git branch -D              # удаление ветки и потеря всех наработок(используется, если ее изменения не влиты в главную ветку)
$ git branch --merged        # показать ветки, уже слитые с активной
$ git branch --no-merged     # показать ветки, не слитые с активной
$ git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
$ git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
$ git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
$ git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
$ git branch --unset-upstream   # завершить процесс переименования
```

### Основы конфликтов при слиянии
Иногда процесс слияния не идет гладко. Если вы изменили одну и ту же часть файла по-разному в двух ветках, которые собираетесь объединить, Git не сможет сделать это чисто. Всё, что имеет отношение к конфликту слияния и что не было разрешено, отмечено как unmerged. При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.
``` bash
$ git merge feature                # влить в активную ветку изменения из ветки feature
$ git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
$ git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
$ git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
$ git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
$ git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
```

### Перемещение 
Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.
``` bash
$ git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)
$ git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature
$ git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase
$ git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)
```

Отмена rebase:
``` bash
$ git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки
$ git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс
```




